;;; nyacc/lang/util.test                -*- scheme -*-
;;; 
;;; Copyright (C) 2015,2016,2023 Matthew Wette
;;; 
;;; Copying and distribution of this file, with or without modification,
;;; are permitted in any medium without royalty provided the copyright
;;; notice and this notice are preserved.  This file is offered as-is,
;;; without any warranty.

;; Test the runtime parsing utilities.
;; examples/nyacc$ guile lang/t-util.scm

(define-module (util)
  #:use-module (nyacc lang util)
  #:use-module (test-suite lib))

(define ctr
  (let ((p (make-count-reporter))) (register-reporter (car p)) ((cadr p))))
(register-reporter full-reporter)

(with-test-prefix "nyacc/util"

  ;; The input-stack used to pull in input from include files.
  (pass-if "input-stack /1"
    (equal?
     "hello world!"
     (with-output-to-string
       (lambda ()
         (with-input-from-string "hello X!"
           (lambda ()
             (let iter ((ch (read-char)))
               (unless (eq? ch #\X) (write-char ch) (iter (read-char))))
             (push-input (open-input-string "world"))
             (let iter ((ch (read-char)))
               (unless (eof-object? ch) (write-char ch) (iter (read-char))))
             (pop-input)
             (let iter ((ch (read-char)))
               (unless (eof-object? ch) (write-char ch) (iter (read-char))))
             ))))))

  ;; Should return #t if something there and #f if done.
  (pass-if "input-stack /2"
    (let ((sp (open-input-string "abc")))
      (reset-input-stack) ;; maybe with-dynamic-extent
      (push-input sp)
      (and (pop-input) (not (pop-input)))))

  (pass-if "tl ops /1"
    (let* ((tl (make-tl 'abc 1)) (tl (tl-append tl 2))
           (tl (tl-insert tl 'b)) (tl (tl-insert tl 'a)))
      (equal? (tl->list tl) '(abc a b 1 2))))

  (pass-if "tl ops /2"
    (let* ((tl (make-tl 'abc 1)) 
           (tl (tl+attr tl 'x "X")) 
           (tl (tl-append tl 2))
           (tl (tl+attr tl 'y "Y")) 
           (tl (tl-insert tl 'b))
           (tl (tl+attr tl 'z "Z")) 
           (tl (tl-insert tl 'a)))
      (equal? (tl->list tl) '(abc (@ (x "X") (y "Y") (z "Z")) a b 1 2))))

  #!
  (pass-if "test3"
    (let* ((tl (make-tl 'abc 1)))
      (set! tl (tl-append tl 2))
      (set! tl (tl-insert tl 'a))
      (set! tl (tl+attr tl 'x "true"))
      (set! tl (tl-append tl 20))
      (set! tl (tl+attr tl 'y "true"))
      (set! tl (tl-append tl 30))
      (set! tl (tl+attr tl 'z "true"))
      (set! tl (tl-append tl 40))
      (set! tl (tl-extend tl '(a b c)))
      (set! tl (tl-insert tl 'YYY))
      (set! tl (tl-append tl 'ZZZ))
      (equal? (tl->list tl)
              '(abc (@ (x "true") (y "true") (z "true"))
                    YYY a 1 2 20 30 40 a b c ZZZ))))
  !#

  )

(exit (if (positive? (assq-ref ctr 'fail)) 1 0))
;;; --- last line ---
