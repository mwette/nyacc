;; nyacc/lang/c99/c99-01.test           -*- scheme -*-
;;
;; Copyright (C) 2017,2023,2024 Matthew Wette
;;
;; Copying and distribution of this file, with or without modification,
;; are permitted in any medium without royalty provided the copyright
;; notice and this notice are preserved.  This file is offered as-is,
;; without any warranty.

;; CPP tests

(define-module (c99-01)
  #:use-module (ice-9 match)
  #:use-module (nyacc lang c99 cpp)
  #:use-module (nyacc lang c99 parser)
  #:use-module (test-suite lib))

(use-modules (ice-9 pretty-print))

(define incs '("exam.d"))

(define (parse-file file)
  (with-input-from-file file
    (lambda ()
      (parse-c99 #:inc-dirs incs #:mode 'code))))

(define* (parse-string str #:key cpp-defs)
  (with-input-from-string str
    (lambda ()
      (parse-c99 #:inc-dirs incs
                 #:cpp-defs (or cpp-defs '())
                 #:mode 'code))))

(define (parse-string-list . str-l)
  (parse-string (apply string-append str-l)))

(define ctr
  (let ((p (make-count-reporter))) (register-reporter (car p)) ((cadr p))))
(register-reporter full-reporter)

(define cpp-define (@@ (nyacc lang c99 cpp) cpp-define))

(define has-inc-defs
  '(("__has_include" ("X")
     ($ident . "__has_include__")
     (#\( . "(") ($hash . "#") ($ident . "X") (#\) . ")"))
    ("__has_include_next" ("X")
     ($ident . "__has_include_next__")
     (#\( . "(") ($hash . "#") ($ident . "X") (#\) . ")"))))

(define (rddef . stl)
  (let* ((str (string-join stl " "))
         (cppdef (with-input-from-string str cpp-define)))
    (match cppdef
      (`(define (name ,name) (args . ,args) (repl ,repl))
       (cons* name args (tokenize-cpp-string repl)))
      (`(define (name ,name) (repl ,repl))
       (cons* name (tokenize-cpp-string repl))))))

;; parser test
(with-test-prefix "nyacc/c99-01, CPP"

  ;; Get a simple statement to parse.
  (pass-if "include in place"
    (equal?
     (parse-file "exam.d/ex07.c")
     '(trans-unit
       (fctn-defn
        (decl-spec-list (type-spec (fixed-type "int")))
        (ftn-declr (ident "foo") (param-list))
        (compd-stmt
         (block-item-list
          (decl (decl-spec-list (type-spec (fixed-type "int")))
                (init-declr-list
                 (init-declr
                  (ident "r")
                  (initzer (p-expr (fixed "1"))))))
          (expr-stmt
           (assn-expr
            (p-expr (ident "r"))
            (op "=")
            (add (p-expr (ident "r")) (p-expr (fixed "1")))))
          (return (p-expr (ident "r")))))))))

  (pass-if "skip space and #"
    (equal?
     (parse-file "exam.d/ex08.c")
     '(trans-unit
       (fctn-defn
        (decl-spec-list (type-spec (fixed-type "int")))
        (ftn-declr (ident "foo") (param-list))
        (compd-stmt
         (block-item-list
          (expr-stmt
           (cond-expr
            (p-expr (ident "boo"))
            (cast (type-name (decl-spec-list (type-spec (void))))
                  (p-expr (fixed "0")))
            (fctn-call
             (p-expr (ident "assert_fail"))
             (expr-list (p-expr (string "boo"))))))))))))

  (pass-if "#, ##, __VA_ARGS__"
    (equal?
     (parse-file "exam.d/ex12.c")
     '(trans-unit
       (decl (decl-spec-list (type-spec (fixed-type "int")))
             (init-declr-list
              (init-declr
               (ident "x")
               (initzer
                (add (mul (p-expr (fixed "1")) (p-expr (fixed "2")))
                     (fctn-call
                      (p-expr (ident "bar"))
                      (expr-list (p-expr (fixed "0")) (p-expr (fixed "1"))
                                 (p-expr (fixed "2")) (p-expr (fixed "3"))
                                 (p-expr (fixed "4"))
                                 (mul (p-expr (fixed "2"))
                                      (p-expr (fixed "3"))))))))))
       (decl (decl-spec-list
              (stor-spec (static)) (type-spec (fixed-type "char")))
             (init-declr-list
              (init-declr (ptr-declr (pointer) (ident "y"))
                          (initzer (p-expr (string "bar"))))))
       (decl (decl-spec-list (type-spec (fixed-type "int")))
             (init-declr-list
              (init-declr
               (ident "z") (initzer (p-expr (ident "ex12_abc2")))))))))

  (pass-if "__VA_ARGS__ w/ arg"
    (equal?
     (parse-string-list
      "#define ISR(vector, ...) void vector (__VA_ARGS__) \n"
      "ISR(__vector__12__, int c) { int x; }\n")
     '(trans-unit
       (fctn-defn
        (decl-spec-list (type-spec (void)))
        (ftn-declr
         (ident "__vector__12__")
         (param-list
          (param-decl
           (decl-spec-list (type-spec (fixed-type "int")))
           (param-declr (ident "c")))))
        (compd-stmt
         (block-item-list
          (decl (decl-spec-list (type-spec (fixed-type "int")))
                (init-declr-list (init-declr (ident "x"))))))))))

  (pass-if "__VA_ARGS__ w/o arg"
    (equal?
     (parse-string-list
      "#define ISR(vector, ...) void vector (__VA_ARGS__) \n"
      "ISR(__vector__12__) { int x; }\n")
     '(trans-unit
       (fctn-defn
        (decl-spec-list (type-spec (void)))
        (ftn-declr (ident "__vector__12__") (param-list))
        (compd-stmt
         (block-item-list
          (decl (decl-spec-list (type-spec (fixed-type "int")))
                (init-declr-list (init-declr (ident "x"))))))))))

  (pass-if "spacing in tokenization"
    (let ((sx1 (parse-string "#define foo(X) # X\nchar *s = foo(abc def);\n"))
          (sx2 (parse-string "#define foo(X) # X\nchar *s = foo(abc  def);\n")))
      (equal? sx1 sx2)))

  (pass-if "def-def-ref"
    (equal?
     (parse-string-list
      "#define A 123\n"
      "#define B A\n"
      "#if B > 0\n"
      "int x;\n"
      "#else\n"
      "char x;\n"
      "#endif\n")
     '(trans-unit
       (decl (decl-spec-list (type-spec (fixed-type "int")))
             (init-declr-list (init-declr (ident "x")))))))

  (pass-if "repeat in arg"
    (equal?
     (parse-string-list
      "#define bar(x,y) foo(x,y)\n"
      "#define foo(x,y) bar(x,y)\n"
      "#define FOO(x,y) foo(x,y)\n"
      "int x = FOO(FOO(1,2),3);\n")
     '(trans-unit
       (decl (decl-spec-list (type-spec (fixed-type "int")))
             (init-declr-list
              (init-declr
               (ident "x")
               (initzer
                (fctn-call
                 (p-expr (ident "foo"))
                 (expr-list
                  (fctn-call
                   (p-expr (ident "foo"))
                   (expr-list (p-expr (fixed "1")) (p-expr (fixed "2"))))
                  (p-expr (fixed "3")))))))))))

  (pass-if "multiple"
    (and
     (equal?

      (parse-string "#define inc(X) X++ + 1\nint x = inc(a);")
      '(trans-unit
       (decl (decl-spec-list (type-spec (fixed-type "int")))
             (init-declr-list
              (init-declr
               (ident "x")
               (initzer
                (add (post-inc (p-expr (ident "a")))
                     (p-expr (fixed "1")))))))))

     (equal?
      (parse-string "#define sqrt(X) sqrt(X)\ndouble x = sqrt(2.0);\n")
      '(trans-unit
        (decl (decl-spec-list
               (type-spec (float-type "double")))
              (init-declr-list
               (init-declr
                (ident "x")
                (initzer
                 (fctn-call
                  (p-expr (ident "sqrt"))
                  (expr-list (p-expr (float "2.0"))))))))))

     #t))

  (pass-if "cond expr w/ undefined idents"
    (equal?
     (parse-string "#if X539101Z\nint x;\n#else\ndouble x;\n#endif\n")
     '(trans-unit
      (decl (decl-spec-list
             (type-spec (float-type "double")))
            (init-declr-list (init-declr (ident "x")))))))

  (pass-if "include w/ #defined arg "
    (pair? (parse-file "exam.d/ex15.c")))

  ;; This breaks prior to 0.81.0  I think we need more testing on
  ;; possible escapes.  See esc-str in cpp.c.
  (pass-if "CPP string building"
    (if (parse-string-list
         "int x;\n"
         "#define XYZ \"bar \\\"-baz\\\"\"\n"
         "char *s = XYZ;\n") #t #f))

  ;; User needs to #define __has_include __has_include__
  (pass-if "__has_include"
    (and
     (equal?
      (parse-string-list
       "#if __has_include (\"exam.d/inc.h\")\n"
       "int x;\n"
       "#else\n"
       "char x;\n"
       "#endif\n")
      '(trans-unit
        (decl (decl-spec-list (type-spec (fixed-type "int")))
              (init-declr-list (init-declr (ident "x"))))))
     (equal?
      (parse-string-list
       "#if __has_include (<exam.d/inc.h>)\n"
       "int x;\n"
       "#else\n"
       "char x;\n"
       "#endif\n")
      '(trans-unit
        (decl (decl-spec-list (type-spec (fixed-type "int")))
              (init-declr-list (init-declr (ident "x"))))))
     (equal?
      (parse-string-list
       "#if __has_include (<xxxx.d/inc.h>)\n"
       "int x;\n"
       "#else\n"
       "char x;\n"
       "#endif\n")
      '(trans-unit
        (decl (decl-spec-list (type-spec (fixed-type "char")))
              (init-declr-list (init-declr (ident "x"))))))
     ))

  (pass-if "Jan's macro-name redef test"
    (equal?
     (parse-file "exam.d/ex17.c")
     '(trans-unit
       (comment " provided by Jan Nieuwenhuizen")
       (comment " worked in 0.80.4, broken in 0.82.1")
       (decl (decl-spec-list
              (type-spec
               (enum-def
                (ident "tcc_token")
                (enum-def-list
                 (enum-defn (ident "TOK_LAST"))
                 (enum-defn (ident "TOK_ASM_mov"))))))))))

  (pass-if "Jan's ELF32_ST_INFO macro test"
    (equal?
     (parse-file "exam.d/ex18.c")
     '(trans-unit
       (decl (decl-spec-list (type-spec (fixed-type "int")))
             (init-declr-list
              (init-declr
               (ident "x")
               (initzer
                (add (lshift
                      (p-expr (fixed "1"))
                      (p-expr (fixed "4")))
                     (bitwise-and
                      (p-expr (fixed "0"))
                      (p-expr (fixed "0xf")))))))))))

  (pass-if "use of comment after #define"
    (equal?
     (parse-string-list
      "#define /* hello */ abc 123\n"
      "int x = abc;\n")
     '(trans-unit
       (decl (decl-spec-list (type-spec (fixed-type "int")))
             (init-declr-list
              (init-declr
               (ident "x")
               (initzer (p-expr (fixed "123")))))))))

  ;; cpp undef
  (pass-if "FOO=#f as #undef"
    (let* ((code
            (string-append
             "#ifdef FOO\n"
             "int ix;\n"
             "#else\n"
             "double xy;\n"
             "#endif\n"))
           (dtree (parse-string code #:cpp-defs '("FOO=1")))
           (utree (parse-string code #:cpp-defs '("FOO=1" "FOO=#f"))))
      (and
       (equal?
        dtree
        '(trans-unit
          (decl (decl-spec-list (type-spec (fixed-type "int")))
                (init-declr-list (init-declr (ident "ix"))))))
       (equal?
        utree
        '(trans-unit
         (decl (decl-spec-list
                (type-spec (float-type "double")))
               (init-declr-list (init-declr (ident "xy")))))))))

  (pass-if "macro-expand-text"
    (and
     (equal?
      (macro-expand-text "FILE" '(("FILE" . "<stdio.h>")))
      "<stdio.h>")
     (equal?
      (macro-expand-text "__has_include(<stdio.h>)" has-inc-defs)
      "__has_include__(\"<stdio.h>\")")
     (equal?
      (macro-expand-text "defined FOO" '(("FOO" ($string "random"))))
      "defined FOO")
     (equal?
      (let* ((defs (list (rddef "A(x) B(x)+3")
                         (rddef "B(y) y*B(2)"))))
        (macro-expand-text "A(B(1))" defs))
      "1*B(2)*B(2)+3")
     (equal?
      (let* ((defs (list (rddef "SQRT(x)sqrt(1+x)"))))
        (macro-expand-text "SQRT(SQRT(3))" defs))
      "sqrt(1+sqrt(1+3))")
     (equal? ;; bug 66626
      (let* ((defs (list
                        (rddef "VALUE(elements) elements.value")
                        (rddef "elements GLOBAL(elements)")
                        (rddef "GLOBAL(name)global.name"))))
        (macro-expand-text "VALUE(elements)" defs))
      "global.elements.value")
     (equal?
      (let* ((defs (list
                    (rddef "foo1(X,Y) ((X)*(Y))")
                    (rddef "foo(A,B,...)"
                           "foo1(A,B)+bar(0, A, B, __VA_ARGS__)"))))
        (macro-expand-text "foo(1, 2, 3, 4, foo1(5,6))" defs))
      "((1)*(2))+bar(0, 1, 2, 3, 4, ((5)*(6)))")
     (equal?
      (let* ((defs
               (list (rddef "assert(x) ((x) ? (void)0 : assert_fail (#x))"))))
        (macro-expand-text "assert(boo);" defs))
      "((boo) ? (void)0 : assert_fail (\"boo\"));")
     (equal?
      (let ((defs (list (rddef "sqrt(X) sqrt(X)+1"))))
        (macro-expand-text "sqrt(2)" defs))
      "sqrt(2)+1")
     (equal?
      (let* ((defs (list (rddef "ELFW(type) ELF##32##_##type")
                         (rddef "ELF32_ST_INFO(bind,type)"
                                "(((bind) << 4) + ((type) & 0xf))"))))
        (macro-expand-text "ELFW(ST_INFO)(1, 0)" defs))
      "(((1) << 4) + ((0) & 0xf))")
     (equal?
      (let* ((defs
               (list (rddef "DEF(id,str) ,id")
                     (rddef "DEF_BWLX DEF_BWL")
                     (rddef "DEF_BWL(x) DEF(TOK_ASM_ ## x, #x)"))))
        (macro-expand-text "DEF_BWLX(mov)" defs))
      ",TOK_ASM_mov")
     (equal?
      (let ((defs '(("bar" ("p" "q") . "foo(p,q)")
                    ("foo" ("r" "s") . "bar(r,s)")
                    ("FOO" ("x" "y") . "foo(x,y)"))))
        (macro-expand-text "FOO(FOO(1,2),3)" defs))
      "foo(foo(1,2),3)")
     (equal?
      (let* ((defs
               (list (rddef "DEF(id,str) ,id")
                     (rddef "DEF_BWLX DEF_BWL")
                     (rddef "DEF_BWL(x) DEF(TOK_ASM_ ## x, #x)"))))
        (macro-expand-text "DEF_BWLX(mov)" defs))
      ",TOK_ASM_mov")
     #t))

  #t)

(exit (if (positive? (assq-ref ctr 'fail)) 1 0))
;; --- last line ---
