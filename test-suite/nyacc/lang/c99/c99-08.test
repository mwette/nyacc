;; nyacc/lang/c99/c99-08.test           -*- scheme -*-
;;
;; Copyright (C) 2024 Matthew Wette
;;
;; Copying and distribution of this file, with or without modification,
;; are permitted in any medium without royalty provided the copyright
;; notice and this notice are preserved.  This file is offered as-is,
;; without any warranty.

;; test constant expression eval's

(define-module (c99-08)
  #:use-module (nyacc lang sx-util)
  #:use-module (nyacc lang c99 parser)
  #:use-module (nyacc lang c99 cxeval)
  #:use-module (nyacc lang c99 munge)
  ;;#:use-module (nyacc lang c99 pprint)
  #:use-module (test-suite lib))
(use-modules (ice-9 pretty-print))
(define pp pretty-print)

(define (fold p s l)
  (let loop ((s s) (l l))
    (if (null? l) s (loop (p (car l) s) (cdr l)))))

(define* (parse-string str)
  (with-input-from-string str parse-c99))

(define ctr
  (let ((p (make-count-reporter))) (register-reporter (car p)) ((cadr p))))
(register-reporter full-reporter)

;; pretty-printer, parser test
;; We generate a tree, send it to the pretty-printer, then through the parser.
;; This should be a unit function, methinks.
(with-test-prefix "nyacc/c99-08, constant expression evaluation"

  (when (string=? %host-type "x86_64-pc-linux-gnu")

    ;; loop simple through pretty-printer
    (pass-if "sizeof"
      (let* ((code
              (string-append
               "struct foo { int iv; double dv; } x;\n"
               "long vsz = sizeof(x);"
               "long tsz = sizeof(struct foo);"))
             (tree (parse-string code))
             (udict (c99-trans-unit->udict tree))
             (val-vsz (eval-c99-cx (sx-ref* tree 2 2 1 2 1) udict))
             (val-tsz (eval-c99-cx (sx-ref* tree 3 2 1 2 1) udict)))
        (and (eq? val-vsz 16) (eq? val-tsz 16))))

    (pass-if "offsetof"
      (let* ((code
              (string-append
               "struct foo { int iv; double dv; } x;\n"
               "long tsz = __builtin_offsetof(struct foo, dv);"
               ))
             (tree (parse-string code))
             (udict (c99-trans-unit->udict tree))
             (exp-tos (sx-ref* tree 2 2 1 2 1))
             (val-tos (eval-c99-cx exp-tos udict))
             )
        ;;(and (eq? osof-tsz 16) (eq? szof-tsv 16))
        (pp exp-tos)
        (pp val-tos)
        #t))

    ))

(exit (if (positive? (assq-ref ctr 'fail)) 1 0))
;; --- last line ---
