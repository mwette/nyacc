;; system/foreign/cdata-01.scm		-*- scheme -*-
;;
;; Copyright (C) 2024 Matthew Wette
;;
;; Copying and distribution of this file, with or without modification,
;; are permitted in any medium without royalty provided the copyright
;; notice and this notice are preserved.  This file is offered as-is,
;; without any warranty.

;; This module will test cstruct getter/setters w/ bitfields to make
;; sure we are doing it right.   For random structures w/ bitfields
;; we generate the cdata and ccode to manipulate the bitfields.  We
;; make foreign function calls to make sure they agree.

(define-module (cdata-01)
  #:use-module (ice-9 match)
  #:use-module (ice-9 format)
  #:use-module ((srfi srfi-1) #:select (fold))
  #:use-module (system foreign)
  #:use-module (system foreign-library)
  #:use-module (system foreign arch-info)
  #:use-module (system foreign cdata)
  #:use-module (test-suite lib))

(define ctr
  (let ((p (make-count-reporter))) (register-reporter (car p)) ((cadr p))))
(register-reporter full-reporter)

(define (unload-foreign-library lib)
  ((@@ (system foreign-library) dlclose)
   ((@@ (system foreign-library) foreign-library-handle) lib)))

(define (tsym->str tsym)
  (string-map (lambda (c) (if (char=? #\- c) #\space c)) (symbol->string tsym)))

(set! *random-state* (random-state-from-platform))

;; to make random struct with n fields
(define names #(0 a b c d e f g h i j k l m n o p q r))
(define types #(int unsigned-int short unsigned-short float double))
(define ntype (vector-length types))
(define nitype (- ntype 2))

(define* (make-rand-fields n #:key w/bitfields)
  (define (rtype n) (vector-ref types (random n)))
  (let loop ((flds '()) (pbf #f) (n n))
    (if (zero? n) flds
        (let* ((rndN (if w/bitfields (random 3) 1))
               (cbf (if pbf (positive? rndN) (zero? rndN)))
               (name (vector-ref names n)))
          (loop (cons (if cbf
                          (list name (rtype nitype) (1+ (random 8)))
                          (list name (rtype ntype)))
                      flds)
                cbf (1- n))))))

;; @deffn {Procedure} rand-mtype-val mtype [width]
;; make random value for base type (e.g., s16le), with optional restriction
;; to bitfield width.
;; @end deffn
(define* (rand-mtype-val mtype #:optional width)
  (define (urand bits) (1+ (random (1- (expt 2 (or width bits))))))
  (define (srand bits) (- (random (expt 2 (or width bits)))
                          (expt 2 (1- (or width bits)))))
  (case mtype
    ((u8) (urand 8)) ((i8) (srand 8))
    ((u16 u16le u16be) (urand 16)) ((s16 s16le s16be) (srand 16))
    ((u32 u32le u32be) (urand 32)) ((s32 s32le s32be) (srand 32))
    ((u64 u64le u64be) (urand 64)) ((s64 s64le s64be) (srand 64))
    ((f32 f32le f32be f64 f64le f64be)
     (* (1- (* 2.0 (random 2))) (* (random (expt 2 8)))
        (expt (exact->inexact 2) (- (random 8) (random 8)))))))

;; ----- run it ---------------------------

(define *nfld* 5)
(define *ntst* 1)
(define c99-basename "ztest")
(use-modules (system foreign))
(use-modules (system foreign-library))

(define (gen-c99-test-code kind kase)
  ;; kind is 'struct or 'union
  (define kstr (if (symbol? kind) (symbol->string kind) kind))
  (define ksym (if (string? kind) (string->symbol kind) kind))
  (define fields (cdr kase))
  (define sn (string-append "test" (number->string (car kase))))
  (define (mk-field fld)
    (if (= 3 (length fld))
        (format #f "  ~a ~a: ~a;\n" (tsym->str (cadr fld)) (car fld) (caddr fld))
        (format #f "  ~a ~a;\n" (tsym->str (cadr fld)) (car fld))))
  (define (mk-sparam fld)
    (format #f ", ~a ~a" (tsym->str (list-ref fld 1)) (list-ref fld 0)))
  (define (mk-gparam fld)
    (format #f ", ~a *~a" (tsym->str (list-ref fld 1)) (list-ref fld 0)))
  (define (mk-setter ix fld)
    (format #f "  if (n == ~a) t->~a = ~a;\n"
            ix (list-ref fld 0) (list-ref fld 0)))
  (define (mk-getter ix fld)
    (format #f "  if (n == ~a) *~a = t->~a;\n"
            ix (list-ref fld 0) (list-ref fld 0)))
  (string-append
   kstr " " sn " {\n"
   (apply string-append (map mk-field fields)) "};\n\n"
   "unsigned long " sn "_siz(" kstr " " sn " *t) {\n"
   "  //printf(\"\\tsizeof=>%lu\\n\", sizeof(*t));\n"
   "  return sizeof(*t);\n}\n\n"
   "void " sn "_set(" kstr " " sn " *t, int n"
   (apply string-append (map mk-sparam fields)) ") {\n"
   (apply string-append (map mk-setter (iota *nfld*) fields))
   "}\n\n"
   "void " sn "_get(" kstr " " sn " *t, int n"
   (apply string-append (map mk-gparam fields)) ") {\n"
   (apply string-append (map mk-getter (iota *nfld*) fields))
   "}\n\n\n"))

(define (gen-c99-test-code/struct k) (gen-c99-test-code 'struct k))
(define (gen-c99-test-code/union k) (gen-c99-test-code 'union k))

(define (gen-code/struct cases)
  (system "rm -f ztest.c ztest.so")
  (let ((port (open-output-file (string-append c99-basename ".c"))))
    (display "#include <stdio.h>\n\n" port)
    (for-each (lambda (code) (display code port))
              (map gen-c99-test-code/struct cases))
    (display
     "int Zmain() { struct test0 *t; printf(\"%lu\\n\", sizeof(*t)); }\n\n"
     port)
    (close-port port))
  (system (simple-format #f "gcc -g -o ~a.so -shared -fPIC ~a.c"
                         c99-basename c99-basename))
  c99-basename)

(define (gen-code/union cases)
  (system "rm -f ztest.c ztest.so")
  (with-output-to-file (string-append c99-basename ".c")
    (lambda ()
      (display "#include <stdio.h>\n\n")
      (for-each (lambda (code) (display code))
                (map gen-c99-test-code/union cases))
      (display
       "int Zmain() { union test0 *t; printf(\"%lu\\n\", sizeof(*t)); }\n\n")
      (force-output)))
  ;;(gc)
  (system (simple-format #f "gcc -g -o ~a.so -shared -fPIC ~a.c"
                         c99-basename c99-basename))
  c99-basename)

(define* (exec-test case-num fields testlib kind #:optional (m-count 10))
  (define (field->rand-val fld)
    (rand-mtype-val (mtypeof-basetype (cadr fld))
                    (and (pair? (cddr fld)) (caddr fld))))
  (define (type->ffi t) (ctype->ffi (mtypeof-basetype t)))

  (define caggate (case kind ((struct) cstruct) ((union) cunion)))

  (let* ((zname (string-append "test" (number->string case-num) "_siz"))
         (sname (string-append "test" (number->string case-num) "_set"))
         (gname (string-append "test" (number->string case-num) "_get"))
         (names (map car fields))
         (types (map cadr fields))
         (t-ct (caggate
                (map (lambda (fld)
                       (match fld
                         ((name type) (list name (cbase type)))
                         ((name type width) (list name (cbase type) width))))
                     fields)))
         (size (ctype-size t-ct))
         (t-cd (make-cdata t-ct))
         (sptr (bytevector->pointer (cdata-bv t-cd)))
         (siz-ftn
          (pointer->procedure
           unsigned-long (foreign-library-pointer testlib zname) (list '*)))
         (set-ftn
          (pointer->procedure
           void (foreign-library-pointer testlib sname)
           (cons* '* int (map (lambda (t) (ctype->ffi (cbase t)))types))))
         (get-ftn
          (pointer->procedure
           void (foreign-library-pointer testlib gname)
           (cons* '* int (map (lambda (t) '*) types))))
         (vars (map (lambda (t) (make-cdata (cbase t))) types))
         (refs (map (lambda (v) (bytevector->pointer (cdata-bv v))) vars)))
    (fold
     (lambda (n seed)
       (let* ((vals (map field->rand-val fields)))
         (and seed
              (let ((res (siz-ftn sptr)))
                (unless (eqv? size res)
                  (format #t "\tmissed size: scm=~s vs c99=~s\n" size res)
                  (format #t "\t             ~s\n" fields))
                #t)
              (eqv? size (siz-ftn sptr))
              (fold
               (lambda (ix name type val seed)
                 (apply set-ftn sptr ix vals)
                 (unless (eqv? val (cdata-ref (cdata-sel t-cd name)))
                   (format #t "\tmissed ref: ~s ~s\n" name val)
                   (format #t "\t            ~s\n" fields)
                   (format #t "\t            ~s\n" (cdata-ref t-cd name)))
                 (and (eqv? val (cdata-ref (cdata-sel t-cd name))) seed))
               #t (iota *nfld*) names types vals)
              (fold
               (lambda (ix name type var val seed)
                 (cdata-set! (cdata-sel t-cd name) val)
                 (apply get-ftn sptr ix refs)
                 (unless (eqv? val (cdata-ref var))
                   (format #t "\tmissed set: ~s ~s\n" name val)
                   (format #t "\t               ~s\n" fields))
                 (and (eqv? val (cdata-ref var)) seed))
               #t (iota *nfld*) names types vars vals))))
    #t (iota m-count))))


;; executing do-test twice makes it always crash
(define* (do-test/struct #:optional (n-count 10) (m-count 10))
  (let* ((cases (map (lambda (ix)
                       (cons ix (make-rand-fields *nfld* #:w/bitfields #t)))
                     (iota n-count)))
         (basename (gen-code/struct cases))
         (ldlibenv #f)
         (testlib #f))
    (dynamic-wind
      (lambda ()
        (set! ldlibenv (getenv "LD_LIBRARY_PATH"))
        (putenv (format #f "LD_LIBRARY_ENV=~s:~s" (getcwd) ldlibenv))
        (set! testlib (load-foreign-library
                       basename #:search-path (list (getcwd)))))
      (lambda ()
        (fold
         (lambda (kase seed)
           (and seed (exec-test (car kase) (cdr kase) testlib 'struct m-count)))
         #t cases))
      (lambda ()
        (unload-foreign-library testlib)
        (putenv (format #f "LD_LIBRARY_PATH=~s" ldlibenv))))))

(define* (do-test/union #:optional (n-count 10) (m-count 10))
  (let* ((cases (map (lambda (ix)
                       (cons ix (make-rand-fields *nfld* #:w/bitfields #f)))
                     (iota n-count)))
         (basename (gen-code/union cases))
         (ldlibenv #f)
         (testlib #f))
    (dynamic-wind
      (lambda ()
        (set! ldlibenv (getenv "LD_LIBRARY_PATH"))
        (putenv (format #f "LD_LIBRARY_ENV=~s:~s" (getcwd) ldlibenv))
        (set! testlib (load-foreign-library
                       basename #:search-path (list (getcwd)))))
      (lambda ()
        (fold
         (lambda (kase seed)
           (and seed (exec-test (car kase) (cdr kase) testlib 'union m-count)))
         #t cases))
      (lambda ()
        (unload-foreign-library testlib)
        (putenv (format #f "LD_LIBRARY_PATH=~s" ldlibenv))))))

(with-test-prefix "system/foreign/cdata"

  (pass-if "struct layout vs C (with bitfields)"
    ;; exec 10 random layouts with 10 random field values each
    (do-test/struct 10 10))

  (pass-if "union layout vs C"
    ;; exec 10 random layouts with 10 random field values each
    (do-test/union 10 10)))

(exit (if (positive? (assq-ref ctr 'fail)) 1 0))

;; --- last line ---a
