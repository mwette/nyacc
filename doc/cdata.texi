\input texinfo.tex
@setfilename cdata.info
@settitle The C-data Module for Guile

@clear no-skip

@copying
Copyright (C) 2024 -- Matthew Wette

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.
@end copying

@headings off
@everyfooting @| @thispage @|

@format
C-Data Reference Manual
Matt Wette
September 2024
@end format

@ifnottex
@node Top, Introduction, (dir), (dir)
@top CData Reference Manual
This is a user guide for the NYACC CData Module
@end ifnottex

@menu
* Introduction ::
@end menu

@node Introduction
@heading Introduction

The @emph{cdata} module and its partner @emph{arch-info} provide a
way to work with data originating from C libraries.  Size and
alignment is tracked for all 
types.  Types are classified into the following kinds: base, struct,
union, array, pointer, enum and function.
The module has been designed with the goals of being easy to
understand and easy to use.  The procedures
@code{cbase}, @code{cstruct}, @code{cunion}, @code{cpointer},
@code{carray}, @code{cenum} and @code{cfunction} generate @emph{ctype}
objects, and the procedure @code{make-cdata} will generate data
objects for ctyped data.  The underlying data is stored in Scheme
bytevectors.  Access to component data is provided by the
@code{cdata-ref} procedure and mutation is 
accomplished via the @code{cdata-set!} procedure.  
The modules support non-native machine architectures via a
global @code{*arch*} parameter.

To include the cdata module in your code use
@code{(use-modules (nyacc foreign cdata))}.

Beyond size and
alignment, base type objects carry a symbolic tag to determine the
appropriate low level machine type.
The low level machine types map directly to bytevector setters
and getters.  Support for C base types is handled by the @code{cbase}
procedure which converts them to underlying types.  For example, on a
64 bit little endian architecture, @code{(cbase 'uintptr_t)} would
generate a type with underlying machine symbol @code{u64le}.

Here is a simple example using structures:

@example
(define timeval (cstruct '((tv_sec long) (tv_usec long))))

(define gettimeofday
  (foreign-library-function
   #f "gettimeofday"
   #:return-type (ctype->ffi (cbase 'int))
   #:arg-types (map ctype->ffi
                    (list (cpointer timeval)
                          (cpointer 'void)))))

(define d1 (make-cdata timeval))
(gettimeofday (cdata-ref (cdata& d1)) %null-pointer)
(format #t "time: ~s ~s\n"
        (cdata-ref d1 'tv_sec) (cdata-ref d1 'tv_usec))
time: 1719062561 676365
@end example

@heading Basic Usage

This section provides the most-used procedures.

@deffn {Procedure} cbase name
Given symbolic @var{name} generate a base ctype.   The name can
be something like @code{unsigned-int}, @code{double}, or can be a
@emph{cdata} machine type like @code{u64le}.
@end deffn

@deffn {Procedure} cpointer type
Generate a C pointer type to @var{type}. To reference or de-reference
cdata object see @code{cdata&} and @code{cdata*}.  @var{type} can be
the symbol @code{void} or a symbolic name used as argument to @code{cbase}.
@*note: Should we allow @var{type} to be a promise?
@example
(define foo_t (cbase 'int))
(cpointer (delay foo_t))
@end example
@end deffn

@deffn {Procedure} cstruct fields [packed] => ctype
Construct a struct ctype with given @var{fields}.  If @var{packed},
@code{#f} by default, is @code{#t}, create a packed structure.
@var{fields} is a list with entries of the form @code{(name type)} or
@code{(name type lenth)} where @code{name} is a symbol or @code{#f}
(for anonymous structs and unions), @code{type} is a @code{<ctype>}
object or a symbol for a base type and @code{length} is the length
of the associated bitfield.
@end deffn

@deffn {Procedure} cunion fields
Construct a ctype union type with given @var{fields}.
See @emph{cstruct} for a description of the @var{fields} argument.
@end deffn

@deffn {Procedure} carray type n
Create an array of @var{type} with @var{length}.
If @var{length} is zero, the array length is unbounded: it's length
can be specified as argument to @code{make-cdata}.
@end deffn


@deffn {Procedure} cenum enum-list [packed]
@var{enum-list} is a list of name or name-value pairs
@example
(cenum '((a 1) b (c 4))
@end example
If @var{packed} is @code{#t} the size wil be smallest that can hold it.
@end deffn


@deffn {Procedure} cfunction proc->ptr ptr->proc [variadic?]
Generate a C function pointer type.  You must pass the @var{wrapper}
and @var{unwrapper} procedures that convert a pointer to a procedure,
and procedure to pointer, respectively.  The optional argument
@var{#:variadic}, if @code{#t},  indicates the function uses variadic
arguments.  For this case, (to be documented).
@end deffn

@deffn {Procedure} make-cdata type [value]
Generate a @emph{cdata} object of type @var{type} with optional @var{value}.
As a special case, an integer arg to a zero-sized array type will allocate
storage for that many items, associating it with an array type of that size.
@end deffn

@deffn {Procedure} cdata-ref data [tag ...]
Return the Scheme (scalar) slot value for selected @var{tag ...} with
respect to the cdata object @var{data}.
@example
(cdata-ref my-struct-value 'a 'b 'c))
@end example
This procedure returns XXX for cdata kinds @emph{base}, @emph{pointer} and
(in the future) @emph{function}.  Attempting to obtain values for C-type
kinds @emph{struct}, @emph{union}, @emph{array} will result in @code{#f}.
If, in those cases, you would like a cdata then use this:
@example
(or (cdata-ref data tag ...) (cdata-sel data tag ...))
@end example
(Or should we just make this the default behavior?)
@end deffn


@deffn {Procedure} cdata-set! data value [tag ...]
Set slot for selcted @var{tag ...} with respect to cdata @var{data} to
@var{value}.  Example:
@example
(cdata-set! my-struct-data 42 'a 'b 'c))
@end example
If @var{value} is a @code{<cdata>} object copy that, if types match.
@*If @var{value} can be a procedure used to set a cfunction pointer
value.
@end deffn

@deffn {Procedure} cdata& data => cdata
Generate a reference (i.e., cpointer) to the contents in the underlying
bytevector.
@end deffn


@heading Going Further

@deffn {Procedure} cdata-sel data tag ... => cdata
Return a new @code{cdata} object representing the associated selection.
Note this is different from @code{cdata-ref}: it always returns a cdata
object.  For example,
@example
> (define t1 (cstruct '((a int) (b double))))
> (define d1 (make-cdata t1))
> (cdata-set! d1 42 'a)
> (cdata-sel d1 'a)
$1 = #<cdata s32le 0x77bbf8e52260>
> (cdata-ref $1)
$2 = 42
@end example
@end deffn

@deffn {Procedure} cdata* data => cdata
De-reference a pointer.  Returns a @emph{cdata} object representing the
contents at the address in the underlying bytevector.
@end deffn

@deffn {Procedure} cdata&-ref data [tag ...]
Does not work work (yet) for march offset addresses.
@end deffn

@deffn {Procedure} cdata*-ref data [tag ...]
Shortcut for @code{(cdata-ref (cdata* data tag ...))}
@end deffn

@deffn {Procedure} Xcdata-ref bv ix ct -> value
Reference a deconstructed cdata object. See @emph{cdata-ref}.
@end deffn

@deffn {Procedure} Xcdata-set! bv ix ct value
Reference a deconstructed cdata object. See @emph{cdata-set!}.
@end deffn

@heading Working with Types

@deffn {Procedure} name-ctype name type => <ctype>
Create a new named version of the type.  The name is useful when the type
is printed.  This procedure does not mutate: a new type object is created.
If a specific type is used by multiple names the names can share
the underlying type guts.  The following generates two named types.
@example
(define raw (cstruct '((a 'int) (b 'double))))
(define foo_t (name-ctype 'foo_t raw))
(define struct-foo (name-ctype 'struct-foo raw))
@end example
These types are equal:
@example
(ctype-equal? foo_t struct-foo) => #t
@end example
@end deffn

@deffn {Procedure} ctype-equal? a b
This predicate assesses equality of it's arguments.
Two types are considered equal if they have the same size,
alignment, kind, and eqivalent kind-specific properties.
For base types, the symbolic mtype must be equal; this includes
size, integer versus float, and signed versus unsigned.
For struct and union kinds, the names and types of all fields
must be equal.
@*TODO: algorithm to prevent infinite search for recursive structs
@end deffn

@deffn {Procedure} ctype-sel type ix [tag ...] => ((ix . ct) (ix . ct) ...)
This generate a list of (offset, type) pairs for a type.  The result is
used to create getters and setter for foreign machine architectures.
See @emph{make-cdata-getter} and @emph{make-cdata-setter}.
@end deffn

@deffn {Procedure} make-cdata-getter sel [offset] => lambda
Genererate a procedure that given a cdata object will fetch the value
at indicated by the @var{sel}, generated by @code{ctype-sel}.
The procedure takes one argument: @code{(proc data [tag ...])}.
Pointer dereference tags (@code{'*'}) are not allowed.
The optional @var{offset} argument (default 0), is used for cross
target use: it is the offset of the address in the host context.
@end deffn 

@deffn {Procedure} make-cdata-setter sel [offset] => lambda
Genererate a procedure that given a cdata object will set the value
at the offset given the selector, generated by @code{ctype-sel}.
The procedure takes two arguments: @code{(proc data value [tag ...])}.
Pointer dereference tags (@code{'*'}) are not allowed.
The optional @var{offset} argument (default 0), is used for cross
target use: it is the offset of the address in the host context.
@end deffn 


@heading Working with C Function Calls

The procedure
@code{ctype->ffi} is a helper for using Guile's
@emph{pointer->procedure}.

@deffn {Procedure} ccast type data [do-check] => <cdata>
need to be able to cast array to pointer
@example
(ccast Target* val)
@end example
@end deffn

@deffn {Procedure} unwrap-number arg => number
Convert an argument to numeric form for a ffi procedure call.
This will reference a cdata object or pass a number through.
@end deffn


@deffn {Procedure} unwrap-pointer arg [hint] => pointer
Convert an argument to a Guile pointer for a ffi procedure call.
This will reference a cdata object or pass a number through.
If the argument is a function, it will attempt to convert that
to a pointer via @code{procedure->pointer} if given the function
pointer type @var{hint}.
@end deffn

@deffn {Procedure} unwrap-array arg => pointer
This will convert an array to a form suitable to pass to a Guile
ffi procedure.
@end deffn

@deffn {Procedure} ctype->ffi ctype => ffi type
Generate a argument spec for Guile's ffi interface.
Example:
@example
(ctype->ffi (cpointer (cbase int))) => '*
@end example
@end deffn

@heading Operations on CType Kinds

The ctype @code{kind} field indicates which kind a type is and
the @code{info} field provide kind-specific information for a ctype.
The @code{name} field provides the type name, if provided, or
@code{#f} if not.

Note that the kind procecures, @code{cstruct}, @{cpointer}, ...,
create @emph{ctype} objects of different @emph{kinds}.  To operate
on kind-specific attributes of types, requries one to fetch the
@code{info} field from the ctype.  From the @code{info} field, one
can then operate using the fields specific to the kind info.

@example
> (define float* (cpointer (cbase 'float)))
> double*
$1 = #<ctype pointer 0x75f3212cbed0>
> (ctype-kind float*)
$2 = pointer
> (define float*-info (ctype-info float*))
> (cpointer-type float*-info)
$3 = #<ctype f32le 0x75f323f8ec90>
> (cpointer-mtype float*-info)
$4 = u64le
@end example
The @code{cpointer-mtype} procedure lets us know that pointers are
stored as unsigned 64 bit (little endian) integers.

The info field for base types is special.  Since the only
kind-specific type information for a base type is the machine type
the info field provides that.  Consider the following example.
@example
> (define foo-t (name-ctype 'foo-t (cbase 'int)))
> (ctype-name foo-t)
$1 = foo-t
> (ctype-kind foo-t)
$2 = base
> (ctype-info foo-t)
$3 = s32le
@end example

Structs are more involved.
@example
> (define bar-s
    (cstruct `((a int) (b float) (#f ,(cstruct '(x int) (y int))))))
> (define bar-s-info (ctype-info bar-s))
> (cstruct-fields bar-s-info)
$4 = (#<<cfield> name: a type: #<ctype s32le 0x75f323f8ecf0> offset: 0>
      #<<cfield> name: b type: #<ctype f32le 0x75f323f8ec90> offset: 4>
      #<<cfield> name: #f type: #<ctype struct 0x75f32181a570> offset: 8>)
> (define x-fld ((cstruct-select bar-s-info) 'x))
> x-fld
$5 = #<<cfield> name: x type: #<ctype s32le 0x75f323f8ecf0> offset: 8>
> (cfield-offset x-fld)
$6 = 8
@end example
Note that the selection of the @code{x} component deals with a
field which is an anonymous struct. The struct @code{bar-s} would look
like the following in C:
@example
struct bar_s {
  int a;
  float b;
  struct {
    int x;
    int y;
  };
};
@end example

And just for kicks
@example
> (define sa 
    (cstruct `((a int) (b double) (#f ,(cstruct '((x short) (y int)))))))
> (define sp 
    (cstruct `((a int) (b double) (#f ,(cstruct '((x short) (y int))))) #t))

> (pretty-print-ctype sa)
(cstruct
  ((a s32le #:offset 0)
   (b f64le #:offset 8)
   (#f
    (cstruct
      ((x s16le #:offset 0) (y s32le #:offset 4)))
    #:offset
    16)))
> (pretty-print-ctype sp)
(cstruct
  ((a s32le #:offset 0)
   (b f64le #:offset 4)
   (#f
    (cstruct
      ((x s16le #:offset 0) (y s32le #:offset 4)))
    #:offset
    12)))
@end example
Note the difference in offsets: @code{sa} is aligned and @code{sp} is
packed.  The offsets reported for anonymous structs can be misleading.
To get the right offsets use select:
@example
> (define tia (ctype-info sa))
> (define tip (ctype-info sp))
> ((cstruct-select tia) 'y)
$8 = 20
> ((cstruct-select tip) 'y)
$9 = 16
@end example

@subheading Enum Conversions

The enum ctype provides procedures to convert between the numeric and
symbolic parts of each enum entry.   Currently, the cdata module does
not provide enum wrapper and unwrapper routines.  However, the FFI
Helper will create these.   The wrapper, converting a number to a
symbol, and unwrapper, converting a symbol to a number, can be
generated as the following example demonstrates.

@example
> (define color_t (cenum '((RED #xf00) (GREEN #x0f0) (BLUE #x00f))))
> (define color_t-info (ctype-info color_t))
> (define wrap-color_t (cenum-symf color_t-info))
> (define unwrap-color_t (cenum-numf color_t-info))
> (wrap-color_t #xf00)
$1 = RED
> (unwrap-color_t 'GREEN)
$2 = 240
@end example


@heading Handling Machine Architectures

One of the author's main motivations for writing CData was to be able
to work with cross-target machine architectures.   This is pretty
cool.  Just to let you know what's going on, consider the following:

@example
> (use-modules (nyacc foreign arch-info))
> (define tx64 (with-arch "x86_64" (cstruct '((a int) (b long)))))
> (define tr64 (with-arch "riscv64" (cstruct '((a int) (b long)))))
> (define tr32 (with-arch "riscv32" (cstruct '((a int) (b long)))))
> (define sp32 (with-arch "sparc" (cstruct '((a int) (b long)))))
> (ctype-equal? tx64 tr64)
$1 = #t
> (ctype-equal? tr64 tr32)
$1 = #f
> (ctype-equal? tr32 ts32)
$1 = #f
> (pretty-print-ctype tx64)
(cstruct ((a s32le #:offset 0) (b s64le #:offset 8)))
> (pretty-print-ctype tr64)
(cstruct ((a s32le #:offset 0) (b s64le #:offset 8)))
> (pretty-print-ctype tr32)
(cstruct ((a s32le #:offset 0) (b s32le #:offset 4)))
> (pretty-print-ctype ts32)
(cstruct ((a s32be #:offset 0) (b s32be #:offset 4)))
@end example

Rocks, right?

arch-info maps base C types to machine types (e.g., i32le) and
alignment for the given machine architecture.    To get sizes, it's a
simple matter of mapping machine types to sizes.

The arch-info module currently has size and alignment information for
the for the following: aarch64, avr, i383, i686, powerpc32, powerpc64,
ppc32, ppc64, riscv32, riscv64, sparc32, sparc64, x86_64.


@heading CData Utilities

@deffn {Procedure} pretty-print-ctype type [port]
Converts type to a literal tree and uses Guile's pretty-print function
to display it.  The default port is the current output port.
@end deffn

@deffn {Procedure} cdata-kind data
Return the kind of @var{data}: pointer, base, struct, ...
@end deffn

@heading Miscellaneous

More to come.

@subheading Base Types

@example
void*
char short int long float double unsigned-short unsigned unsigned-long
size_t ssize_t ptrdiff_t int8_t uint8_t int16_t uint16_t int32_t
uint32_t int64_t uint64_t signed-char unsigned-char short-int
signed-short signed-short-int signed signed-int long-int signed-long
signed-long-int unsigned-short-int unsigned-int unsigned-long-int
_Bool bool intptr_t uintptr_t wchar_t char16_t char32_t long-double
long-long long-long-int signed-long-long signed-long-long-int
unsigned-long-long unsigned-long-long-int
@end example

@subheading Other Procedures

More to come.


@subheading Guile FFI Support

More to come.

@deffn {Procedure} ctype->ffi-type type
Convert a @emph{ctype} to the (integer) code for the associated FFI
type.
@end deffn

@subheading Copyright

Copyright (C) 2024 -- Matthew Wette.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.

@heading References

@enumerate
@item Guile Manual:
@url{https://www.gnu.org/software/guile/manual}
@item Scheme Bytestructures:
@url{https://github.com/TaylanUB/scheme-bytestructures}
@end enumerate

@bye
@c --- last line ---
