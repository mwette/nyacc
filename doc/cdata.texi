\input texinfo.tex
@setfilename cdata.info
@settitle The C-data Module for Guile

@clear no-skip

@copying
Copyright (C) 2024-2025 -- Matthew Wette

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.
@end copying

@headings off
@everyfooting @| @thispage @|

@iftex
@format
C-Data Reference Manual
Matt Wette
October 2024
@end format
@end iftex

@ifnottex
@node Top, Introduction, (dir), (dir)
@top CData Reference Manual
@* Matt Wette
@* October 2024
@*
@* This is a user guide for the NYACC CData module for Guile.
@end ifnottex

@dircategory Software development
@direntry 
* NYACC CData User Guide: (nyacc).    The NYACC CData User guide.
@end direntry

@menu
* Introduction ::
@end menu

@node Introduction
@heading Introduction

The @emph{cdata} module (@code{(nyacc foreign cdata)} and its
partner @emph{arch-info} (@code{(nyacc foreign arch-info)} provide a
way to work with data originating from C libraries.  We hope the module
is reasonably easy to understand and use.  Size and alignment is
tracked for all types.  Types are classified into the following kinds:
base, struct, union, array, pointer, enum and function.  The procedures
@code{cbase}, @code{cstruct}, @code{cunion}, @code{cpointer},
@code{carray}, @code{cenum} and @code{cfunction} generate @emph{ctype}
objects, and the procedure @code{make-cdata} will generate data
objects based on these.  The underlying bits of data are stored in Scheme
bytevectors.  Access to component data is provided by the
@code{cdata-ref} procedure and mutation is
accomplished via the @code{cdata-set!} procedure.
The modules support non-native machine architectures via the
global parameter @code{*arch*}.

Beyond size and
alignment, base type objects carry a symbolic tag to determine the
appropriate low level machine type.
The low level machine types map directly to bytevector setters
and getters.  Support for C base types is handled by the @code{cbase}
procedure which converts them to underlying types.  For example, for a
64 bit little endian machine architecture, @code{(cbase 'uintptr_t)} would
generate a type with underlying symbol @code{u64le}.

Here is a simple example of using @emph{cdata} for structures:

@example
(use-modules (system foreign))
(use-modules (system foreign-library))
(use-modules (nyacc foreign cdata))

(define timeval_t
  (cstruct `((tv_sec ,(cbase 'long)) (tv_usec ,(cbase 'long)))))

(define gettimeofday
  (foreign-library-function
   #f "gettimeofday"
   #:return-type (ctype->ffi (cbase 'int))
   #:arg-types (map ctype->ffi
                    (list (cpointer timeval_t)
                          (cpointer 'void)))))

(define d1 (make-cdata timeval_t))
(gettimeofday (cdata-ref (cdata& d1)) %null-pointer)
(format #t "time: ~s ~s\n"
        (cdata-ref d1 'tv_sec) (cdata-ref d1 'tv_usec))
time: 1719062561 676365
@end example
In the above @code{cdata&} generates a cpointer type for @code{d1} and
@code{cdata-ref} extracts the Guile (@code{pointer}) value.

@heading Basic Usage

This section provides an introduction to procedures you are likely to
want on your first approach.

@deffn {Procedure} cbase name => <ctype>
Given symbolic @var{name}, generate a base ctype.   The name can
be something like @code{unsigned}, @code{double}, or can be a
@emph{cdata} machine type like @code{u64le}.  For example,
@example
(define double-type (cbase 'double))
@end example
There is a pseudo-type @code{void}.
@end deffn

@deffn {Procedure} cpointer type => <ctype>
Generate a C pointer type for @var{type}. To reference or de-reference
cdata object see @code{cdata&} and @code{cdata*}.  @var{type} can be
the symbol @code{void} or a symbolic name used as argument to @code{cbase}.
@example
(define foo_t (cbase 'int))
(cpointer (delay foo_t))
@end example
@end deffn

@deffn {Procedure} cstruct fields [packed] => ctype
Construct a struct ctype with given @var{fields}.  If @var{packed},
@code{#f} by default, is @code{#t}, create a packed structure.
@var{fields} is a list with entries of the form @code{(name type)} or
@code{(name type lenth)} where @code{name} is a symbol or @code{#f}
(for anonymous structs and unions), @code{type} is a @code{<ctype>}
object or a symbol for a base type and @code{length} is the length
of the associated bitfield.
@end deffn

@deffn {Procedure} cunion fields => <ctype>
Construct a ctype union type with given @var{fields}.
See @emph{cstruct} for a description of the @var{fields} argument.
@end deffn

@deffn {Procedure} carray type n => <ctype>
Create an array of @var{type} with @var{length}.
If @var{length} is zero, the array length is unbounded: it's length
can be specified as argument to @code{make-cdata}.
@end deffn

@deffn {Procedure} cenum enum-list [packed] => <ctype>
@var{enum-list} is a list of name or name-value pairs
@example
(cenum '((a 1) b (c 4))
@end example
If @var{packed} is @code{#t} the size will be smallest that can hold it,
as if defined in C with @code{__attribute__((packed))}.
@end deffn

@deffn {Procedure} cfunction proc->ptr ptr->proc [variadic?] => <ctype>
Generate a C function type to be used with @code{cpointer}. The arguments
@var{proc->ptr} and @var{ptr->proc} are procedures that convert a
procedure to a pointer, and pointer to procedure, respectively.  The
optional argument @var{#:variadic}, if @code{#t},  indicates the function
uses variadic arguments.  For this case (I need to add documention).
 Here is an example:
@example
(define (f-proc->ptr proc)
  (ffi:procedure->pointer ffi:void proc (list)))
(define (f-ptr->proc fptr)
  (ffi:pointer->procedure ffi:void fptr (list)))
(define ftype (cpointer (cfunction f-proc->ptr f-ptr->proc)))
@end example
The thinking here is that a @code{cfunction} type is a proxy for a
C function in memory, with a getter and setter to read from or write
to memory.
@end deffn

@deffn {Procedure} make-cdata type [value]
Generate a @emph{cdata} object of type @var{type} with optional @var{value}.
If @var{value} is not provided, the object is zeroed.
As a special case, a positive integer arg to a zero-sized array type will
allocate storage for that many items, associating it with an array type of
that size.
@end deffn

@deffn {Procedure} make-cdata/* type pointer
Make a cdata object from a pointer.   That is, instead of creating a
bytevector to hold the data use the memory at the pointer using
@code{pointer->bytevector}.
@end deffn

@deffn {Procedure} cdata-ref data [tag ...] => value
Return the Scheme (scalar) slot value for selected @var{tag ...} with
respect to the cdata object @var{data}.
@example
(cdata-ref my-struct-value 'a 'b 'c))
@end example
This procedure returns Guile values for cdata kinds @emph{base},
@emph{pointer}, @emph{procedure}, @emph{array} (an array) and @emph{struct}
(an alist).  For @emph{union} an exception is raised.   The returned values
are freshly allocated copies. If want a cdata object, use @code{cdata-sel}.
@end deffn


@deffn {Procedure} cdata-set! data value [tag ...]
Set slot for selcted @var{tag ...} with respect to cdata @var{data} to
@var{value}.  Example:
@example
(cdata-set! my-struct-data 42 'a 'b 'c))
@end example
If @var{value} is a @code{<cdata>} object then copy that (if types match).
@*The @var{value} argument can be a Scheme procedure when the associated
ctype is a pointer to function.
@end deffn

Values accepted by @code{cdata-set!} and @code{make-cdata} are as follows,
based on the cdata target ctype.
@enumerate
@item
If the type is a base machine type, then the argument must be an associated
Scheme numeric type.
@item
If the type is a pointer type, the value can be a Guile pointer, an integer
(address), a string, or a procedure (for the case where the type is a function
pointer).
@item
If the type is an array type, TO BE CONTINUED.
@item
If the type is a function type, then an error is returned.  See above
for pointer (to function) types.
@item
If a struct, and the value is
@end enumerate
In addition, if the value is of ctype, a copy of the underlying bytevector
contents will be performed.  An error will be thrown if the types are not equal.
Also, if the value argument to @code{make-cdata} is an integer and
the type argument is an array of length zero, then space is allocated to
accomodate that length array.  Here are some examples:
@example
> (define tri1-t (carray (carray (cbase 'double) 2) 3))
> (define tval1 (make-cdata tri1-t #2f64((1.0 2.0) (3.0 4.0) (5.0 6.0))))
> (cdata-ref tval1)
$1 = #2f64((1.0 2.0) (3.0 4.0) (5.0 6.0))
> (cdata-set! tval1 1.5 0 1)
> (cdata-ref tval1)
$2 = #2f64((1.0 1.5) (3.0 4.0) (5.0 6.0))
>
@end example
and
@example
> (define loc-t (cstruct `((x double) (y double))) 3)
> (define tri2-t (carray loc-t 3))
> (define tval2 (make-cdata tri2-t (vector '((x . 1.0) (y . 2.0))
                                           '((x . 3.0) (y . 4.0))
                                           '((x . 2.0) (y . 5.0)))))
> tval2
$3 = #<cdata array 0x79ae9a077200>
> (cdata-ref tval2)
$4 = #(((x . 1.0) (y . 2.0)) ((x . 3.0) (y . 4.0)) ((x . 2.0) (y . 5.0)))
> (cdata-set! tval2 1.5 0 'x)
> (cdata-ref tval2)
$5 = #(((x . 1.5) (y . 2.0)) ((x . 3.0) (y . 4.0)) ((x . 2.0) (y . 5.0)))
@end example




@deffn {Procedure} cdata& data => cdata
Generate a reference (i.e., cpointer) to the contents in the underlying
bytevector.
@end deffn

@deffn {Procedure} cdata* data => cdata
De-reference a pointer.  Returns a @emph{cdata} object representing the
contents at the address in the underlying bytevector.
@end deffn

@heading Notes

@subheading Digression on Garbage Collection

Before going further we remind you that the underlying datastructure
is bytevectors.  Now, since bytevectors in Guile are not searched for
pointers during garbage collection there is a risk that the objects
being referenced might be collected during usage.  A systematic method
to prevent this is work to go.  One might try to use @code{cdata&} in
the following way keep intermediate values from being collected.
@example
  (let ((val (make-cdata foo_t))
        (ptr (cdata& val)))
     (bar ptr))
@end example


@heading Going Further

@deffn {Procedure} cdata-sel data tag ... => cdata
Return a new @code{cdata} object representing the associated selection.
Note this is different from @code{cdata-ref}: it always returns a cdata
object.  For example,
@example
> (define t1 (cstruct '((a int) (b double))))
> (define d1 (make-cdata t1))
> (cdata-set! d1 42 'a)
> (cdata-sel d1 'a)
$1 = #<cdata s32le 0x77bbf8e52260>
> (cdata-ref $1)
$2 = 42
@end example
@end deffn

@deffn {Procedure} cdata&-ref data [tag ...] => value
Shortcut for @code{(cdata-ref (cdata& data tag ...))}
This always returns a Guile @emph{pointer}.
@end deffn

@deffn {Procedure} cdata*-ref data [tag ...] => value
Shortcut for @code{(cdata-ref (cdata* data tag ...))}
@end deffn

Underneath, cdata data is a triple of bytevector, offset, and
ctype.  In some cases it may be more efficient to work with the
deconstructed triple.  The following two procedures are
provided for working at that level, in addition to the @code{ctype-sel}
procedure described below.

@deffn {Procedure} Xcdata-ref bv ix ct -> value
Reference a deconstructed cdata object. See @emph{cdata-ref}.
@end deffn

@deffn {Procedure} Xcdata-set! bv ix ct value
Set the value of a deconstructed cdata object. See @emph{cdata-set!}.
@end deffn

@heading Working with Types

@deffn {Procedure} name-ctype name type -> <ctype>
Create a new named version of the type.  The name is useful when the type
is printed.  This procedure does not mutate: a new type object is created.
If a specific type is used by multiple names the names can share
the underlying type guts.  The following examples shows how one type
can have two names:
@example
(define raw (cstruct '((a 'int) (b 'double))))
(define foo_t (name-ctype 'foo_t raw))
(define struct-foo (name-ctype 'struct-foo raw))
@end example
These types are equal:
@example
(ctype-equal? foo_t struct-foo) => #t
@end example
It is recommended that one use symbols for names rather than strings,
so that @code{pretty-print-ctype} will use names effectively.
@end deffn

@deffn {Procedure} ctype-eqv? a b => #t|#f
@deffnx {Procedure} ctype-equal? a b => #t|#f
The @code{ctype-eqv?} and @code{ctype-equal?} predicates assesses equality
of their arguments.  Two types are considered equvalent if they have the
same size, alignment, kind, and eqivalent kind-specific properties.  For
base types, the symbolic mtype must be equal; this includes size, integer
versus float, and signed versus unsigned.  For struct and union kinds, the
names and types of all fields must be equal, unless, for @code{ctype-eqv?}
they are pointer types with delays.  The implementation of
@code{ctype-equal?} is not complete: it is currently the same as
@code{ctype-eqv?}.
@end deffn

@deffn {Procedure} ctype-sel type ix [tag ...] => ((ix . ct) (ix . ct) ...)
This generate a list of (offset, type) pairs for a type.  The result is
used to create getters and setter for foreign machine architectures.
See @emph{make-cdata-getter} and @emph{make-cdata-setter}.
@end deffn

The procedure @code{ctype-sel} should be very useful for creating
fast code, with compiled procedures or macros.  It computes offsets
for legs of a selection (e.g., @code{'a 'x '* 3 'b}).   Note that
if a selection includes dereferences (i.e., @code{'*}) then at runtime
the address of the currently processed data must be fetched from memory.
So, for the selection @code{'a 'x '* 3 'b} a list of two offsets will
be produced, looking like the following:
@example
> (ctype-sel some-type 0 'b 'y '* 3 'm)
$1 = ((16 . #<ctype pointer 0x7284a17e2660>)
      (28 . #<ctype s32le 0x7284a2c1d600>))
@end example
To use the above, the application procedure could access a
pointer at offset 16 in the bytevector, create a new bytevector
(via @code{pointer->bytevector}) then generate a cdata via the
low-level procedure @code{%make-cdata} as in
@example
(define data (%make-cdata bv 28 (caadr $1)))
@end example
The following routines use this feature to create quick accessors.
@* TODO: Create a similar procedure that uses case-lambda to do both.


@deffn {Procedure} make-cdata-getter sel [offset] => lambda
Genererate a procedure that given a cdata object will fetch the value
at indicated by the @var{sel}, generated by @code{ctype-sel}.
The procedure takes one argument: @code{(proc data [tag ...])}.
Pointer dereference tags (@code{'*'}) are not allowed.
The optional @var{offset} argument (default 0), is used for cross
target use: it is the offset of the address in the host context.
@end deffn

@deffn {Procedure} make-cdata-setter sel [offset] => lambda
Genererate a procedure that given a cdata object will set the value
at the offset given the selector, generated by @code{ctype-sel}.
The procedure takes two arguments: @code{(proc data value [tag ...])}.
Pointer dereference tags (@code{'*'}) are not allowed.
The optional @var{offset} argument (default 0), is used for cross
target use: it is the offset of the address in the host context.
@end deffn

@deffn {Procedure} ?make-cdata-accessor sel [offset]
This procedure (not final) is similar to @code{make-cdata-getter} and
@code{make-cdata-setter} but the resulting procedure accepts
no tag sequence.  Called with one arg, it's a getter;
called with two args, it's a setter.
@example
> (define ct (cstruct ...))
> (define sel (ctype-sel ct 0 'b 'y '* 3 'm))
> (define *foo* (may-be-make-cdata-accessor sel))
> (define cd (make-cdata ct))
> (*foo* cd 42) ; set value
> (*foo* cd)    ; get value
$1 = 42
@end example
@end deffn

@heading Working with C Function Calls

The procedure @code{ctype->ffi} is a helper for using Guile's
@emph{pointer->procedure}.  It generates an appropriate
@code{(system foreign)} ffi-type for the given cdata type.

@deffn {Procedure} ccast type data [do-check] => <cdata>
Cast a cdata object of one (pointer) type to another (pointer) type.
This routine creates a new cdata object with the target type, but
same bytevector and index.
@example
> (define t1 (cstruct '((a int) (b int))))
> (define t2 (cstruct `((base ,t1) (c int))))
> (define d2 (make-cdata t2))
> (cdata-set! d2 42 'base 'a)
> (define p2 (cdata& d2))
> p2
$1 = #<cdata pointer 0x7c5b59dfac20>
> (define p1 (ccast (cpointer t1) p2))
> (cdata-ref p1 '* 'a)
$2 = 42
> (cdata-ref p2 '* 'base 'a)
$3 = 42
@end example
@end deffn

@deffn {Procedure} arg->number arg => number
Convert an argument to numeric form for a ffi procedure call.
This will reference a cdata object or pass a number through.
@end deffn

The above procedure was previously called @code{unwrap-number}.


@deffn {Procedure} arg->pointer arg [hint] => pointer
Convert an argument to a Guile pointer for a ffi procedure call.
This will reference a cdata object or pass a number through.
If the argument is a function, it will attempt to convert that
to a pointer via @code{procedure->pointer} if given the function
pointer type @var{hint}.
@end deffn

The above procedure used to be called @code{unwrap-pointer}.  It is
also used to implement the old @code{unwrap-array}.

@deffn {Procedure} ctype->ffi ctype => ffi-type
Generate a argument spec for Guile's ffi interface.
Example:
@example
(ctype->ffi (cpointer (cbase int))) => '*
@end example
@end deffn

@heading Operations on CType Kinds

The ctype @code{kind} field indicates which kind a type is and
the @code{info} field provide kind-specific information for a ctype.
The @code{name} field provides the type name, if provided, or
@code{#f} if not.

Note that the kind procecures, @code{cstruct}, @code{cpointer}, ...,
create @emph{ctype} objects of different @emph{kinds}.  To operate
on kind-specific attributes of types, requries one to fetch the
@code{info} field from the ctype.  From the @code{info} field, one
can then operate using the fields specific to the kind info.

@example
> (define float* (cpointer (cbase 'float)))
> double*
$1 = #<ctype pointer 0x75f3212cbed0>
> (ctype-kind float*)
$2 = pointer
> (define float*-info (ctype-info float*))
> (cpointer-type float*-info)
$3 = #<ctype f32le 0x75f323f8ec90>
> (cpointer-mtype float*-info)
$4 = u64le
@end example
The @code{cpointer-mtype} procedure lets us know that pointers are
stored as unsigned 64 bit (little endian) integers.

The info field for base types is special.  Since the only
kind-specific type information for a base type is the machine type
the info field provides that.  Consider the following example.
@example
> (define foo-t (name-ctype 'foo-t (cbase 'int)))
> (ctype-name foo-t)
$1 = foo-t
> (ctype-kind foo-t)
$2 = base
> (ctype-info foo-t)
$3 = s32le
@end example

Structs are more complex.  A struct type object includes a member
@code{cstruct-fields}, list of
it's fields (@code{cfield}), and a member @code{cstruct-select}, a procedure
to lookup fields based on symbolic or string name.  In addition, with
no arg, the select procedure will return a symbolic list of member names.
@example
> (define bar-s
    (cstruct `((a int) (b float) (#f ,(cstruct '(x int) (y int))))))
> (define bar-s-info (ctype-info bar-s))
> (cstruct-fields bar-s-info)
$4 = (#<<cfield> name: a type: #<ctype s32le 0x75f323f8ecf0> offset: 0>
      #<<cfield> name: b type: #<ctype f32le 0x75f323f8ec90> offset: 4>
      #<<cfield> name: #f type: #<ctype struct 0x75f32181a570> offset: 8>)
> (define x-fld ((cstruct-select bar-s-info) 'x))
> x-fld
$5 = #<<cfield> name: x type: #<ctype s32le 0x75f323f8ecf0> offset: 8>
> (cfield-offset x-fld)
$6 = 8
@end example
Note that the selection of the @code{x} component deals with a
field which is an anonymous struct. The struct @code{bar-s} would look
like the following in C:
@example
struct bar_s @{
  int a;
  float b;
  struct @{
    int x;
    int y;
  @};
@};
@end example

And just for kicks
@example
> (define sa
    (cstruct `((a int) (b double) (#f ,(cstruct '((x short) (y int)))))))
> (define sp
    (cstruct `((a int) (b double) (#f ,(cstruct '((x short) (y int))))) #t))

> (pretty-print-ctype sa)
(cstruct
  ((a s32le #:offset 0)
   (b f64le #:offset 8)
   (#f
    (cstruct
      ((x s16le #:offset 0) (y s32le #:offset 4)))
    #:offset
    16)))
> (pretty-print-ctype sp)
(cstruct
  ((a s32le #:offset 0)
   (b f64le #:offset 4)
   (#f
    (cstruct
      ((x s16le #:offset 0) (y s32le #:offset 4)))
    #:offset
    12)))
@end example
Note the difference in offsets: @code{sa} is aligned and @code{sp} is
packed.  The offsets reported for anonymous structs can be misleading.
To get the right offsets use select:
@example
> (define tia (ctype-info sa))
> (define tip (ctype-info sp))
> ((cstruct-select tia) 'y)
$8 = 20
> ((cstruct-select tip) 'y)
$9 = 16
@end example

@subheading Enum Conversions

The enum ctype provides procedures to convert between the numeric and
symbolic parts of each enum entry.   Currently, the cdata module does
not provide enum wrapper and unwrapper routines.  However, the FFI
Helper will create these.   The wrapper, converting a number to a
symbol, and unwrapper, converting a symbol to a number, can be
generated as the following example demonstrates.

@example
> (define color_t (cenum '((RED #xf00) (GREEN #x0f0) (BLUE #x00f))))
> (define color_t-info (ctype-info color_t))
> (define wrap-color_t (cenum-symf color_t-info))
> (define unwrap-color_t (cenum-numf color_t-info))
> (wrap-color_t #xf00)
$1 = RED
> (unwrap-color_t 'GREEN)
$2 = 240
@end example


@heading Handling Machine Architectures

One of the author's main motivations for writing CData was to be able
to work with cross-target machine architectures.   This is pretty
cool.  Just to let you know what's going on, consider the following:

@example
> (use-modules (nyacc foreign arch-info))
> (define tx64 (with-arch "x86_64" (cstruct '((a int) (b long)))))
> (define tr64 (with-arch "riscv64" (cstruct '((a int) (b long)))))
> (define tr32 (with-arch "riscv32" (cstruct '((a int) (b long)))))
> (define sp32 (with-arch "sparc" (cstruct '((a int) (b long)))))
> (ctype-equal? tx64 tr64)
$1 = #t
> (ctype-equal? tr64 tr32)
$1 = #f
> (ctype-equal? tr32 ts32)
$1 = #f
> (pretty-print-ctype tx64)
(cstruct ((a s32le #:offset 0) (b s64le #:offset 8)))
> (pretty-print-ctype tr64)
(cstruct ((a s32le #:offset 0) (b s64le #:offset 8)))
> (pretty-print-ctype tr32)
(cstruct ((a s32le #:offset 0) (b s32le #:offset 4)))
> (pretty-print-ctype ts32)
(cstruct ((a s32be #:offset 0) (b s32be #:offset 4)))
@end example

Rocks, right?

arch-info maps base C types to machine types (e.g., i32le) and
alignment for the given machine architecture.    To get sizes, it's a
simple matter of mapping machine types to sizes.

The arch-info module currently has size and alignment information for
the for the following: aarch64, avr, i383, i686, powerpc32, powerpc64,
ppc32, ppc64, riscv32, riscv64, sparc32, sparc64, x86_64.


@heading CData Utilities

@deffn {Procedure} pretty-print-ctype type [port]
Converts type to a literal tree and uses Guile's pretty-print function
to display it.  The default port is the current output port.
@end deffn

@deffn {Procedure} cdata-kind data
Return the kind of @var{data}: pointer, base, struct, ...
@end deffn

@heading Miscellaneous

More to come.

@subheading Base Types

Base types are the following, along with the pseudo-type @code{void}

@example
void* char signed-char unsigned-char short unsigned-short
float double int unsigned long unsigned-long long-long unsigned-long-long
int8_t uint8_t int16_t uint16_t int32_t uint32_t int64_t uint64_t
size_t ssize_t ptrdiff_t intptr_t uintptr_t _Bool bool
wchar_t char16_t char32_t long-double _Float16 _Float128
float-_Complex double-_Complex __int128 unsigned-__int128
@end example

When it come to multi-named types like ``long long int'' cdata wants
to see the shorted variant, here ``long long''.   Likewise, use
``unsigned'' for ``unsigned int'', ``short'' for ``short int'', etc.

@subheading Other Procedures

More to come.


@subheading Guile FFI Support

More to come.

@deffn {Procedure} ctype->ffi-type type
Convert a @emph{ctype} to the (integer) code for the associated FFI
type.
@end deffn

@subheading Copyright

Copyright (C) 2024 -- Matthew Wette.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included with the distribution as COPYING.DOC.

@heading References

@enumerate
@item Guile Manual:
@url{https://www.gnu.org/software/guile/manual}
@item Scheme Bytestructures:
@url{https://github.com/TaylanUB/scheme-bytestructures}
@end enumerate

@bye
@c --- last line ---
